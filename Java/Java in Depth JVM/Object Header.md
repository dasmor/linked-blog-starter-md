part of [[Java object Layout]]
[[Object]]
Задавались ли вы когда-нибудь вопросом, как выглядят java объекты изнутри?  
Под катом будет подробное описание заголовка java объекта, из чего он состоит и сколько занимает памяти.

  

Для начала вспомним, что в jvm любой объект в памяти состоит из заголовка объекта и переменных объекта (ссылки и примитивы). Также финальный размер объекта может быть расширен, чтобы размер стал кратен 8 байтам.

  

Заголовок каждого объекта (кроме массива) состоит из двух машинных слов — **mark word** и **сlass word**. Массивы имеют дополнительно 32 бита для описания длины массива.

  

В _Mark word_ хранится identity hashcode, биты используемые сборщиком мусора и биты используемые для блокировок. Более подробно можно всегда ознакомиться в соответствующих сорцах OpenJDK [markOop.hpp](http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/markOop.hpp).

  

В _Class word_ хранится указатель на сам класс, то есть, на то место, где лежит информация о данном типе данных: методы, аннотации, наследование и другое. Более подробно можно также всегда ознакомиться в соответствующих сорцах OpenJDK [klass.hpp](http://hg.openjdk.java.net/jdk8/jdk8/hotspot/file/87ee5ee27509/src/share/vm/oops/klass.hpp).

  

Давайте теперь более подробно рассмотрим _заголовок объекта_ и в частности _mark word_

  

## 32 битные jvm

  

![32 bit JVM](https://habrastorage.org/r/w1560/webt/ic/95/vd/ic95vdspq0wgsolqgrwonbgodwo.png)

  

Как видно из таблицы, содержание _Mark word_ может сильно разниться в зависимости от текущего состояния объекта.

  

#### Нормальное состояние объекта (biased_lock = 0, lock = 01)

  

- identity_hashcode — хеш объекта, который появляется лениво. Если у объекта будет впервые вызов System.identityHashCode(obj), то этот хеш будет рассчитан и записан в заголовок объекта.  
    В других состояниях, когда за объект конкурируют различные потоки, identity_hashcode будет храниться уже не в заголовке объекта, а в мониторе объекта.
- age — количество пережитых сборок мусора. Когда age достигает числа max-tenuring-threshold,  
    объект перемещается в область хипа old generation.
- biased_lock — содержит 1, если biased locking включено для этого объекта, иначе 0.

  

**Немного подробней**

  

- lock — содержит код состояние блокировки. 00 — Lightweight Locked, 01 — Unlocked or Biased, 10 — Heavyweight Locked, 11 — Marked for Garbage Collection.

  

То есть в таблице состояние объекта определяют совокупность битов biased_lock и lock.

  

#### Режим Biased Locked (biased_lock = 1, lock = 01)

  

- thread — в режиме biased блокировки предполагается, что объектом преимущественно владеет какой-то конкретный поток, в поле хранится id этого потока.
- epoch содержит некоторый временной индикатор владения объектом потоком, id которого сохранено в thread

  

#### Режим Lightweight Locked (lock = 00)

  

В этом режиме предполагается, что время захвата данным объектом разными потоками не пересекается вообще или пересекается незначительно. В этом режиме вместо тяжеловесных блокировок операционной системы, JVM использует атомики.

  

- ptr_to_lock_record — для установки/ожидания блокировки используется CAS (compare and set) внутри цикла spin loop.  
    Для справки, минимальное время блокировки ОС будет в районе порядка 10 мс, при помощи атомиков поток не засыпает, а продолжает молотить небольшой цикл, и как только ресурс освободится, цикл с атомиком закончится, и поток тут же захватит этот объект.

  

#### Режим Heavyweight Locked (lock = 10)

  

- ptr_to_heavyweight_monitor — если время захвата данным объектом различными потоками будет значительно пересекаться, то lightweight lock будет заменена на heavyweight lock. В ptr_to_heavyweight_monitor будет записан указатель на монитор. Используется блокировка ОС.

  

Итак в 32 битной jvm хедер объекта состоит из 8 байт. Массивы дополнительно имеют 4 байта.

  

## 64 битные jvm

  

![64 bit JVM](https://habrastorage.org/r/w1560/webt/gz/hm/ks/gzhmksgyzo2rowjnnm85g62ldu4.png)

  

На 64 битной jvm хедер объекта состоит из 16 байт. Массивы дополнительно имеют 4 байта.

  

## 64 битные jvm с сжатием указателей

  

![64 bit JVM  Coops](https://habrastorage.org/r/w1560/webt/xt/58/lp/xt58lpwwgpxsxky_gjwivje0ub0.png)

  

Хедер объекта состоит из 12 байт. Массивы дополнительно имеют 4 байта.

  

Немного о сжатии указателей. Для 32 битного указателя адресное пространство ограничено 4Гб. Однако если снова вспомнить, что в jvm размер объекта кратен 8 байтам, то мы можем использовать псевдо 35 битный указатель, с тремя нулями на конце. И, таким образом, ссылаться уже на 32Гб памяти. Сжатие получается не бесплатное, цена — дополнительная операция (pointer << 3) при любом обращении в heap.

  

#### Ссылка на оригинальную статью:

  

[Java Object Header](http://arturmkrtchyan.com/java-object-header)

  

Также хотел бы добавить, что всё здесь описанное не является догмой, возможно, в других версиях jvm заголовок объекта будет отличаться. Описанное тут актуально для openjdk 8.
